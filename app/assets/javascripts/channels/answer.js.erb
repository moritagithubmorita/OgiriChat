/*global $*/

/*
  対戦を管理するjs

  2種類のユーザ状態(「参戦」、「観覧」)それぞれの処理を担う。

*/

/* 以下、対戦の各フェーズのdelay。battle()で使用
   1.各お題の開始時間からのdelay
    SET_DELAY/START_ANSWER_DELAY/FINISH_ANSWER_DELAY
   2.対戦終了時間からのdelay
    FINISH_BATTLE_DELAY
*/
let SET_DELAY = 2000
let START_ANSWER_DELAY = 3000
//let FINISH_ANSWER_DELAY = 123000
let FINISH_ANSWER_DELAY = 10000 // 開発用
let FINISH_BATTLE_DELAY = 2000

let connected_channel_count = 0 // 接続済みチャンネル数
let submit_is_active = false  //submit送信の有効/無効
let answerChannels = {} // チャンネルサブスクリプションs
let current_ac_key = "qr1"  // 現在のお題に紐づいたAnswerChannelを指すキー(answerChannels)
let qr_bodies = null  // QuestionRoomのお題s
let qr_ids_answer = null; // 今回使うQuestionRoomのids
let is_audience = undefined;  //観覧ならtrue/参戦ならfalseを後で代入する

$(document).on('turbolinks:load', function(){
  qr_ids_answer = $('#question').data('question-room-ids'); // 今回使う問題のidを取得
  qr_bodies = $('#question').data('question-room-bodies'); // 今回使う問題のbodyを取得
  // 観覧かどうか
  is_audience = $('#question').data('is-audience'); // 観覧ならtrueが入っている
  if(is_audience!=true){
    is_audience = false;
  }

  // 回答用のチャンネルをサブスクライブする
  var cnt = 1
  $.each(qr_ids_answer, function(key, value){
    var keyName = "qr"+cnt
    answerChannels[keyName] = App.cable.subscriptions.create({channel: "AnswerChannel", question_room_id: value}, {

      // 全ての回答用チャンネルをサブスクライブできたら対戦を開始する
      connected: function() {
        // Called when the subscription is ready for use on the server
        console.log('connected')
        connected_channel_count+=1

        if(qr_ids_answer != undefined){
          // 全ての接続が完了したらお題をスタートする
          if(connected_channel_count==Object.keys(qr_ids_answer).length){
            if(!is_audience){
              battle_manager()  //対戦を管理する関数
            }else{
              battle_manager_audience() //対戦管理関数(観覧用)
            }
          }
        }
      },

      disconnected: function() {
        // Called when the subscription has been terminated by the server
      },

      // 回答を受け取り表示(append())する
      received: function(data) {
        return $('#answers').prepend(data['message'])
      },

      // 回答
      // サーバーに回答を送信する
      answer: function(qr_id, answer) {
        return this.perform('answer', {
              qr_id: qr_id,
              answer: answer
            });
      },

      // その時点までの回答を全取得(戻り値:部分テンプレート)
      get_all_answers: function(qr_id){
        return this.perform('get_all_answers', {
            qr_id: qr_id
        });
      },

    });
    cnt+=1
  })
})

// 対戦を管理する(参戦用)
function battle_manager(){
  /* 処理内容
    1.各問題をスケジューリングする
      ※setIntervalは使用せず、1回のeachで全ての問題に関するスケジューリングをしてしまう
    2.対戦終了をスケジューリング
  */

  console.log('対戦スタート')

  // 対戦をスケジューリング
  // 1問目の準備〜3問目の終了処理までのスケジューリング
  var cnt = 1
  $.each(answerChannels, function(key, value){
    battle(cnt)
    cnt+=1
  })

  // 対戦終了
  var elapsed_time = FINISH_ANSWER_DELAY*(cnt-1)
  finish_battle(elapsed_time+FINISH_BATTLE_DELAY)
}

// 対戦を管理する(観覧用)
function battle_manager_audience(){
  /* 処理内容
    1.経過時間を計算する
    2.対戦をスケジューリング
      ・なお観覧は参戦時のbattle()関数のようなものはなく、以下のコードでスケジュールする
      ・また、観覧の場合start_answering、prepare_answeringは必要ないためスケジュールしない
    3.これまでの投稿を全表示
      ・よくないが、スケジューリングの過程で現在の問題がわかるので、そのタイミングでやってしまう。
  */

  // 1.経過時間計算
  var start_time = $('#question').data('start-time'); // 開始時間を文字列で取得[ミリ秒]
  var current_time = new Date();
  var elapsed_time = current_time.getTime() - start_time; //[ミリ秒]

  // 2.対戦スケジューリング(および3.観覧開始までの投稿を全表示)
  var cnt = 1;  // 何問目か
  var sum = 0;  // 対戦の各フェーズのdelayを足していく
  $.each(answerChannels, function(key, value){
    var diff = 0; // sum-elapsed_time
    sum += SET_DELAY;
    diff = sum - elapsed_time;
    if(diff>=0){
      set_question(qr_bodies[`qr${cnt}_body`], diff);
    }else{
      var nextDiff = sum+START_ANSWER_DELAY+FINISH_ANSWER_DELAY-elapsed_time;
      if(nextDiff>=0){
        set_question(qr_bodies[`qr${cnt}_body`], 0);
        current_ac_key=`qr${cnt}`;
        // 3.これまでの投稿を全表示
        let qr_ids_key = $('#question').data('current-qr-ids-answer-key');  // qr_ids_answerのキーを作成
        answerChannels[current_ac_key].get_all_answers(qr_ids_answer[qr_ids_key]);  // チャンネルに指定お題の回答を全て含んだ外部テンプレート送付を依頼
      }
    }

    sum += (START_ANSWER_DELAY+FINISH_ANSWER_DELAY);
    diff = sum - elapsed_time;
    if(diff>=0){
      finish_answering(diff, cnt);
    }else{
      var nextDiff = sum+SET_DELAY-elapsed_time;
      if(nextDiff>=0){
        finish_answering(0, cnt);
        current_ac_key=`qr${cnt+1}`;  // 最終問題の終了処理まで終わってた場合は問題数+1のキーが生まれるが、参照には使わないので大丈夫。
      }
    }

    cnt+=1;
  });
  sum += FINISH_BATTLE_DELAY;
  finish_battle(sum-elapsed_time);

}

// 対戦の準備(観覧用)
function prepare_battle_audience(){
  /* 処理内容
    1.フォームを消す
    2.これまでの投稿を一括表示
  */

  // フォームを消す
  $('#answer-form').remove();
  $('#submit').remove()

  // 観覧開始までの投稿を一括表示
}

// 1回の対戦そのもの
function battle(cnt){
  //cnt...現在の出題数

  var elapsed_time = FINISH_ANSWER_DELAY*(cnt-1) // 前の問題終了時点までに経過した時間

  console.log("battle()")
  // お題を表示
  set_question(qr_bodies[`qr${cnt}_body`], SET_DELAY+elapsed_time, cnt)
  // 回答開始
  start_answering(START_ANSWER_DELAY+elapsed_time)
  // 終了
  finish_answering(FINISH_ANSWER_DELAY+elapsed_time, cnt)
}

// お題出題
function set_question(question_room_body, delay, cnt){
  /* 処理内容
    1.現在のお題キー(qr_ids_answerにおける)を#questionのdata-current-qr-ids-answer-keyに保存
    2.お題をセット、表示
  */
  console.log("set_question()")

  setTimeout(function(){
    // 現在のお題のキー(qr_ids_answer)を設定
    let current_qr_ids_answer_key = $('#question').data('current-qr-ids-answer-key');
    // 今回が第一問目の場合、先頭のお題を登録
    // なお1ではなくcnt(第問題目か)を使ってるのは観覧用。参戦では1が来るはずだから問題ない。
    if(current_qr_ids_answer_key == "start"){
      $('#question').data('current-qr-ids-answer-key', `qr${cnt}_id`);
    }
    // 今回が2問目以降である場合、次のお題のidを登録
    else{
      let str = current_qr_ids_answer_key.replace("qr", "");
      str = str.replace("_id", "");
      $('#question').data('current-qr-ids-answer-key', `qr${parseInt(str)+1}_id`)
    }

    // お題を表示
    $('#question').text(question_room_body)
    }
    , delay)
}

// 回答準備
function prepare_answering(){
  console.log('prepare_answering()')

  // 送信ボタンを有効化
  enable_submit(true)
}

// 回答開始
function start_answering(delay){
  console.log('start_answering()')

  // 回答準備
  setTimeout(function(){
    prepare_answering()
  }
  ,delay)
}

// 回答終了
function finish_answering(delay, cnt){
  console.log('finish_answering()')

  setTimeout(function(){
    $('#question').text('終了！');
    // 次のお題の準備
    prepare_for_next(cnt);
  }
  ,delay)
}

// 終了処理、次のお題の準備
function prepare_for_next(cnt){
  console.log('prepare_for_next()')

  // cnt...現在の出題数

  /* 処理内容
    1.submitを無効化
    2.フォームに入力中の内容を消す
    3.回答を消す(表示を消す)
    4.お題を進める(current_ac_key処理)
  */

  // submitを無効化
  enable_submit(false)

  //フォームに入力中の内容を消す
  $('#answer-form').val("");

  //表示されている回答を消す
  $('.answer').remove();

  // current_ac_keyを進める
  current_ac_key = "qr"+(cnt+1)

}

// 対戦終了
function finish_battle(delay){
  console.log('finish_battle()')

  setTimeout(function(){
    // ねぎらいページへ遷移
    window.location.href = `<%= Rails.application.routes.url_helpers.finish_path %>?qr1_id=${qr_ids_answer.qr1_id}&qr2_id=${qr_ids_answer.qr2_id}&qr3_id=${qr_ids_answer.qr3_id}&is_audience=${is_audience}`
  }, delay)
}

// submitボタンを有効/無効
function enable_submit(flag){
  submit_is_active=flag // フラグ処理
  $('#submit').toggleClass("submit--active")  // 色を変える
}

// submitボタンが押されたらサーバに回答を送信する
// submit_is_activeがfalseなら回答を送らない
$(document).on('turbolinks:load', function(){
  $('#submit').on('click', function(event){
    if($('#answer-form').val()!=""){
      if(submit_is_active){
        let qr_ids_key = $('#question').data('current-qr-ids-answer-key')
        answerChannels[current_ac_key].answer(qr_ids_answer[qr_ids_key], $('#answer-form').val());
        $('#answer-form').val('');
      }
    }
  });
});